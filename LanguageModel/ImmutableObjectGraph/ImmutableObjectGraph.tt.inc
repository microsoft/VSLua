<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="$(ProjectDir)$(OutDir)System.Collections.Immutable.dll" #>
<#@ assembly name="$(ProjectDir)$(OutDir)ImmutableObjectGraph.dll" #>
<#@ Import Namespace="ImmutableObjectGraph" #>
<#@ Import namespace="System.Globalization" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Collections.Immutable" #>
<#@ Import Namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ Import namespace="System.Text" #>
<#@ Import namespace="System.Data.Entity.Design.PluralizationServices" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Discovery.tt.inc" #>
<# if (this.DefineInterfaces) { #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Interface.tt.inc" #>
<# } #>
<# if (this.DefineWithMethodsPerProperty) { #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.WithProperty.tt.inc" #>
<# } #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.CollectionHelpers.tt.inc" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.DeepMutation.tt.inc" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.FastSpine.tt.inc" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.TypeConversion.tt.inc" #>
<# if (this.DefineBuilders) { #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Builders.tt.inc" #>
<# }
	this.PluralService = PluralizationService.CreateService(CultureInfo.CurrentCulture);
#>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;
	using System.Linq;
	using ImmutableObjectGraph;
<#
	foreach(string ns in this.ImportNamespaces) { #>
	using <#= ns #>;
<#	}

	this.PushIndent("\t");
	foreach(var templateType in TemplateTypes) {
		this.OnHandleType(templateType, HandleTypePosition.BeforeTypeDeclaration);

		var baseTypes = new List<string>();
		if (templateType.HasAncestor) {
			baseTypes.Add(templateType.Ancestor.TypeName);
		}

		if (this.DefineInterfaces) {
			baseTypes.Add("I" + templateType.TypeName);
		}

		if (templateType.IsRecursiveParent) {
			baseTypes.Add("System.Collections.Generic.IEnumerable<" + templateType.RecursiveType.TypeName + ">");
			if (templateType.ChildrenAreSorted) {
				baseTypes.Add("IRecursiveParentWithSortedChildren");
			} else if (templateType.ChildrenAreOrdered) {
				baseTypes.Add("IRecursiveParentWithOrderedChildren");
			}

			baseTypes.Add("IRecursiveParent<" + templateType.RecursiveType.TypeName + ">");
		}

		if (templateType.IsRecursiveType) {
			baseTypes.Add("IRecursiveType");
		}

		OnContributeBaseTypes(templateType, baseTypes);
#>

public <#= templateType.IsAbstract ? "abstract " : "" #>partial class <#= templateType.TypeName #><# if (baseTypes.Count > 0) { #> : <#= String.Join(", ", baseTypes) #><# } #> {
<#	if (!templateType.IsAbstract) { #>
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.TypeName #> DefaultInstance = GetDefaultTemplate();
<#	}

	if (!templateType.HasAncestor) {
#>
	
	/// <summary>The last identity assigned to a created instance.</summary>
	private static int lastIdentityProduced;
<#
	}

	foreach(var field in templateType.LocalFields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= field.TypeName #> <#= field.NameCamelCase #>;
<#
	}

	if (!templateType.HasAncestor) {
#>

	private readonly <#= templateType.RequiredIdentityField.TypeName #> <#= templateType.RequiredIdentityField.NameCamelCase #>;
<#
	}
#>

<#
	bool firstInSequence = true;
#>
	/// <summary>Initializes a new instance of the <#= templateType.TypeName #> class.</summary>
	protected <#= templateType.TypeName #>(<#
		WriteParameters(templateType.RequiredIdentityField.Concat(templateType.AllFields), ParameterStyle.Required);
		if (templateType.Equals(templateType.RecursiveParent)) {
			WriteParameters(new [] { templateType.LookupTableField }, ParameterStyle.Optional, concatenated: true);
		}
#>,
		ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
<# if (templateType.HasAncestor) { #>
		: base(<# WriteArguments(templateType.RequiredIdentityField.Concat(templateType.AllFields.Where(f => f.DeclaringType != templateType)), ArgSource.Argument); #>)
<# } #>
	{
<#
	if (!templateType.HasAncestor) {
#>
		this.<#= templateType.RequiredIdentityField.NameCamelCase #> = <#= templateType.RequiredIdentityField.NameCamelCase #>;
<#
	}

	foreach(var field in templateType.LocalFields) {
#>
		this.<#= field.NameCamelCase #> = <#= field.NameCamelCase #>;
<#
	}

	if (!templateType.IsAbstract) {
#>
		if (!skipValidation.Value) {
			this.Validate();
		}
<#	} #>
<#	OnHandleType(templateType, HandleTypePosition.InsideConstructor); #>
	}
<#
	if (!templateType.IsAbstract) { #>

	public static <#= templateType.TypeName #> Create(<# WriteParameters(templateType.AllFields, ParameterStyle.OptionalOrRequired); #>) {
		var <#= templateType.RequiredIdentityField.NameCamelCase #> = Optional.For(NewIdentity());
		return DefaultInstance<# if (templateType.AllFields.Count > 0) { #>.WithFactory(<#
		WriteArguments(templateType.AllFields.Concat(templateType.OptionalIdentityField), ArgSource.OptionalArgumentOrTemplate, asOptional: OptionalStyle.Always);
#>)<# } /* if (templateType.AllFields.Count > 0) */ #>;
	}
<#
	} // !IsAbstract Create factory method

	foreach(var field in templateType.LocalFields) {
#>

	public <#= field.TypeName #> <#= field.NamePascalCase #> {
		get { return this.<#= field.NameCamelCase #>; }
	}
<#  } // foreach Fields

	foreach(var field in templateType.AllFields) {
		this.OnHandleField(templateType, field);
	}

	if (!templateType.IsAbstract) {
		foreach (var ancestor in templateType.Ancestors.Reverse().Where(a => a.LocalFields.Any())) {
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	protected override <#= ancestor.TypeName #> WithCore(<# WriteParameters(ancestor.AllFields, ParameterStyle.Optional); #>) {
		return this.WithFactory(<#
			WriteArguments(ancestor.AllFields, ArgSource.Argument);
#>);
	}
<#
		} // foreach ancestor
	} // templateType.HasAncestor

	if (templateType.AllFields.Any()) { #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.TypeName #> With(<#
		WriteParameters(templateType.AllFields, ParameterStyle.Optional);
#>) {
		return (<#= templateType.TypeName #>)this.WithCore(<# WriteArguments(templateType.AllFields, ArgSource.Argument); #>);
	}
<#	if (templateType.LocalFields.Any()) { #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	protected <#= templateType.IsAbstract ? "abstract" : "virtual" #> <#= templateType.TypeName #> WithCore(<#
		WriteParameters(templateType.AllFields, ParameterStyle.Optional);
#>)<# if (templateType.IsAbstract) { #>;
<# } else { #> {
		var <#= templateType.RequiredIdentityField.NameCamelCase #> = default(<#= templateType.RequiredIdentityField.OptionalTypeName#>);
		return this.WithFactory(<# WriteArguments(templateType.AllFields.Concat(templateType.OptionalIdentityField), ArgSource.OptionalArgumentOrProperty, asOptional: OptionalStyle.Always); #>);
	}
<#	} // else !IsAbstract
		} /* if LocalFields.Any() */

		if (!templateType.IsAbstract) {
 #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	private <#= templateType.TypeName #> WithFactory(<# WriteParameters(templateType.AllFields.Concat(templateType.OptionalIdentityField), ParameterStyle.Optional); #>) {
		if (<#
			firstInSequence = true;
			foreach(var field in templateType.RequiredIdentityField.Concat(templateType.AllFields)) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= field.NameCamelCase #>.IsDefined && <#= field.NameCamelCase #>.Value != this.<#= field.NamePascalCase #>)<#
				firstInSequence = false;
			}
	#>) {
<#
			if (templateType.Equals(templateType.RecursiveParent)) {
#>
			var <#= templateType.LookupTableField.NameCamelCase #> = <#= templateType.RecursiveField.NameCamelCase #>.IsDefined && <#= templateType.RecursiveField.NameCamelCase #>.Value != this.<#= templateType.RecursiveField.NamePascalCase #> ? default(Optional<<#= templateType.NodeLookupTableTypeName #>>) : Optional.For(this.lookupTable);
<#
			}
#>
			return new <#= templateType.TypeName #>(<#
				WriteArguments(templateType.RequiredIdentityField.Concat(templateType.AllFields), ArgSource.OptionalArgumentOrProperty, indent: 4);
				if (templateType.Equals(templateType.RecursiveParent)) {
					WriteArguments(new [] { templateType.LookupTableField }, ArgSource.Argument, indent: 4, concatenated: true);
				}
#>);
		} else {
			return this;
		}
	}
<#
		}
	} /* templateType.AllFields.Count > 0 */
	
	if (!templateType.HasAncestor) {
#>

	protected internal uint <#= templateType.RequiredIdentityField.NamePascalCase #> {
		get { return (uint)this.<#= templateType.RequiredIdentityField.NameCamelCase #>; }
	}

	/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
	protected static <#= templateType.RequiredIdentityField.TypeName #> NewIdentity() {
		return (<#= templateType.RequiredIdentityField.TypeName #>)System.Threading.Interlocked.Increment(ref lastIdentityProduced);
	}
<#	} // !templateType.HasAncestor

	if (templateType.IsRecursive) { #>

	public System.Collections.Generic.IEnumerator<<#=templateType.RecursiveType.TypeName#>> GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}
<# }
	if (!templateType.IsAbstract) { #>

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.TypeName #> whose fields are initialized with default values.</summary>
	private static <#= templateType.TypeName #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.TypeName #>(<#
		this.PushIndent("\t\t\t");

		// Value parameters
		WriteLine("");
		Write("default({0})", templateType.RequiredIdentityField.TypeName);
		foreach(var field in templateType.AllFields) {
			WriteLine(",");
			Write("template.");
			Write(field.NamePascalCase);
		}

		WriteLine(",");
		Write("skipValidation: true");
		this.PopIndent();
#>);
	}
<# } /* !IsAbstract */
if (!templateType.IsAbstract) { #>

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in templateType.AllFields) {
#>

		internal <#= field.TypeName #> <#= field.NamePascalCase #> { get; set; }
<#
	}
#>
	}
<#	} /* !IsAbstract */

	this.OnHandleType(templateType, HandleTypePosition.WithinTypeDeclaration, indent: 1);

	if (templateType.IsRecursiveParent) {
#>

	System.Collections.Generic.IEnumerable<IRecursiveType> IRecursiveParent.Children {
		get { return this.Children; }
	}

	System.Collections.Generic.IEnumerable<<#= templateType.RecursiveType.TypeName #>> IRecursiveParent<<#= templateType.RecursiveType.TypeName #>>.Children {
		get { return this.Children; }
	}

	ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType> IRecursiveParent.GetParentedNode(<#= templateType.RequiredIdentityField.TypeName #> identity) {
		var parented = this.GetParentedNode(identity);
		return new ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType>(parented.Value, parented.Parent);
	}
<#
		if (templateType.ChildrenAreOrdered) {
#>
	int IRecursiveParentWithOrderedChildren.IndexOf(IRecursiveType value) {
		return this.Children.IndexOf((<#= templateType.RecursiveType.TypeName #>)value);
	}
<#
			if (templateType.ChildrenAreSorted) {
#>
	int IRecursiveParentWithSortedChildren.Compare(IRecursiveType first, IRecursiveType second) {
		return this.Children.KeyComparer.Compare((<#= templateType.RecursiveType.TypeName #>)first, (<#= templateType.RecursiveType.TypeName #>)second);
	}
<#
			} // children are sorted
		} // children are ordered
	}

	if (templateType.IsRecursiveType) {
#>

	<#= templateType.RequiredIdentityField.TypeName #> IRecursiveType.Identity {
		get { return this.Identity; }
	}
<#
	}
#>
}
<#
		this.OnHandleType(templateType, HandleTypePosition.AfterTypeDeclaration);
	} // looping over all template types

	this.PopIndent();
#>
}

<#+
	public bool DefineInterfaces { get; set; }

	public bool DefineBuilders { get; set; }

	public bool DefineWithMethodsPerProperty { get; set; }

	public PluralizationService PluralService { get; set; }

	public string Namespace { get; set; }

	public HashSet<string> ImportNamespaces = new HashSet<string>();

	protected enum HandleTypePosition {
		BeforeTypeDeclaration,

		InsideConstructor,

		WithinTypeDeclaration,

		AfterTypeDeclaration,
	}

	protected event Action<MetaType, HandleTypePosition> HandleType;

	protected event Action<MetaType, List<string>> ContributeBaseTypes;

	protected event Action<MetaType, HandleTypePosition> HandleRedType;

	protected event Action<MetaType, MetaType.MetaField> HandleField;

	protected event Action<MetaType, MetaType.MetaField> HandleRedField;

	protected void OnContributeBaseTypes(MetaType type, List<string> baseTypes) {
		var handler = this.ContributeBaseTypes;
		if (handler != null) {
			handler(type, baseTypes);
		}
	}

	protected void OnHandleType(MetaType type, HandleTypePosition position, int indent = 0) {
		var handleType = this.HandleType;
		if (handleType != null) {
			this.PushIndent(new string('\t', indent));
			handleType(type, position);
			this.PopIndent();
		}
	}

	protected void OnHandleRedType(MetaType type, HandleTypePosition position, int indent = 0) {
		var handleRedType = this.HandleRedType;
		if (handleRedType != null) {
			this.PushIndent(new string('\t', indent));
			handleRedType(type, position);
			this.PopIndent();
		}
	}

	protected void OnHandleField(MetaType type, MetaType.MetaField field) {
		var handleField = this.HandleField;
		if (handleField != null) {
			this.PushIndent("\t");
			handleField(type, field);
			this.PopIndent();
		}
	}

	protected void OnHandleRedField(MetaType type, MetaType.MetaField field) {
		var handleRedField = this.HandleRedField;
		if (handleRedField != null) {
			this.PushIndent("\t");
			handleRedField(type, field);
			this.PopIndent();
		}
	}

	protected void WriteBaseTypes(params string[] typeNames) {
		var elements = typeNames.Where(t => t != null);
		if (elements.Any()) {
			Write(" : ");
			bool firstElement = true;
			foreach (var element in elements) {
				if (!firstElement) {
					Write(", ");
				}

				Write(element);
				firstElement = false;
			}
		}
	}
#>
